--- t2cstr.c	2019-04-03 14:16:49.346349386 +0200
+++ t2cstr_redzones.c	2019-04-03 14:16:38.078402067 +0200
@@ -22,7 +22,7 @@
 #include <limits.h>
 #include <stdlib.h>
 #include <errno.h>
-
+#include <sanitizer/asan_interface.h>
 /* Make uzoperator for internal use */
 #define t2_cntroff t2_reservedESC33
 
@@ -70,14 +70,14 @@
     struct /* Operand stack */
     {
         long cnt;
-        float array[CFF2_MAX_OP_STACK];
+        float pre_array[8], array[CFF2_MAX_OP_STACK], post_array[8];
         unsigned short numRegions;
         long blendCnt;
-        abfOpEntry blendArray[CFF2_MAX_OP_STACK];
-        abfBlendArg blendArgs[T2_MAX_STEMS];
+        abfOpEntry pre_blendArray[8], blendArray[CFF2_MAX_OP_STACK], post_blendArray[8];
+        abfBlendArg pre_blendArgs[8], blendArgs[T2_MAX_STEMS], post_blendArgs[8];
     } stack;
     long maxOpStack;
-    float BCA[TX_BCA_LENGTH]; /* BuildCharArray */
+    float pre_BCA[8], BCA[TX_BCA_LENGTH], post_BCA[8]; /* BuildCharArray */
     float x;                  /* Path x-coord */
     float y;                  /* Path y-coord */
     int subrDepth;
@@ -92,20 +92,20 @@
         int nMasters;
         int leIndex;
         int composeOpCnt;
-        float composeOpArray[TX_MAX_OP_STACK_CUBE];
-        double WV[kMaxCubeMasters]; /* Was originally just 4, to support substitution MM fonts. Note: the PFR rasterizer can support only up to 5 axes */
-    } cube[CUBE_LE_STACKDEPTH];
+        float pre_composeOpArray[8], composeOpArray[TX_MAX_OP_STACK_CUBE], post_composeOpArray[8];
+        double pre_WV[8], WV[kMaxCubeMasters], post_WV[8]; /* Was originally just 4, to support substitution MM fonts. Note: the PFR rasterizer can support only up to 5 axes */
+    } pre_cube, cube[CUBE_LE_STACKDEPTH], post_cube;
     struct /* Stem hints */
     {
         long cnt;
-        Stem array[T2_MAX_STEMS];
+        Stem pre_array[8], array[T2_MAX_STEMS], post_array[8];
     } stems;
     struct /* hint/cntrmask */
     {
         short state;                           /* cntrmask state */
         short length;                          /* Number of bytes in mask op */
         short unused;                          /* Mask unused bits in last byte of mask */
-        unsigned char bytes[T2_MAX_STEMS / 8]; /* Current mask */
+        unsigned char pre_bytes[8], bytes[T2_MAX_STEMS / 8], post_bytes[8]; /* Current mask */
     } mask;
     struct /* seac conversion data */
     {
@@ -124,7 +124,7 @@
     short LanguageGroup;
     t2cAuxData *aux;                                /* Auxiliary parse data */
     unsigned short gid;                             /* glyph ID */
-    unsigned short regionIndices[CFF2_MAX_MASTERS]; /* variable font region indices */
+    unsigned short pre_regionIndices[8], regionIndices[CFF2_MAX_MASTERS], post_regionIndices[8]; /* variable font region indices */
     cff2GlyphCallbacks *cff2;                       /* CFF2 font callbacks */
     abfGlyphCallbacks *glyph;                       /* Glyph callbacks */
     ctlMemoryCallbacks *mem;                        /* Glyph callbacks */
@@ -172,7 +172,7 @@
 static int t2Decode(t2cCtx h, long offset);
 static void convertToAbsolute(t2cCtx h, float x1, float y1, abfBlendArg *blendArgs, int num);
 static void copyBlendArgs(t2cCtx h, abfBlendArg *blendArg, abfOpEntry *opEntry);
-
+static void PoisonArrays(t2cCtx h);
 /* ------------------------------- Error handling -------------------------- */
 
 /* Write message to debug stream from va_list. */
@@ -2521,7 +2521,7 @@
 
 /* Parse Type 2 charstring. */
 int t2cParse(long offset, long endOffset, t2cAuxData *aux, unsigned short gid, cff2GlyphCallbacks *cff2, abfGlyphCallbacks *glyph, ctlMemoryCallbacks *mem) {
-    struct _t2cCtx h;
+    struct _t2cCtx h; PoisonArrays(&h);
     int retVal;
     /* Initialize */
     h.flags = PEND_WIDTH | PEND_MASK;
@@ -2623,3 +2623,33 @@
         };
     return (err_code < 0 || err_code >= (int)ARRAY_LEN(errstrs)) ? "unknown error" : errstrs[err_code];
 }
+
+static void PoisonArrays(t2cCtx h) {
+  int i;
+
+  ASAN_POISON_MEMORY_REGION(&h->stack.pre_array, sizeof(h->stack.pre_array));
+  ASAN_POISON_MEMORY_REGION(&h->stack.pre_blendArray, sizeof(h->stack.pre_blendArray));
+  ASAN_POISON_MEMORY_REGION(&h->stack.pre_blendArgs, sizeof(h->stack.pre_blendArgs));
+  ASAN_POISON_MEMORY_REGION(&h->pre_BCA, sizeof(h->pre_BCA));
+  ASAN_POISON_MEMORY_REGION(&h->pre_cube, sizeof(h->pre_cube));
+  ASAN_POISON_MEMORY_REGION(&h->stems.pre_array, sizeof(h->stems.pre_array));
+  ASAN_POISON_MEMORY_REGION(&h->mask.pre_bytes, sizeof(h->mask.pre_bytes));
+  ASAN_POISON_MEMORY_REGION(&h->pre_regionIndices, sizeof(h->pre_regionIndices));
+
+  ASAN_POISON_MEMORY_REGION(&h->stack.post_array, sizeof(h->stack.post_array));
+  ASAN_POISON_MEMORY_REGION(&h->stack.post_blendArray, sizeof(h->stack.post_blendArray));
+  ASAN_POISON_MEMORY_REGION(&h->stack.post_blendArgs, sizeof(h->stack.post_blendArgs));
+  ASAN_POISON_MEMORY_REGION(&h->post_BCA, sizeof(h->post_BCA));
+  ASAN_POISON_MEMORY_REGION(&h->post_cube, sizeof(h->post_cube));
+  ASAN_POISON_MEMORY_REGION(&h->stems.post_array, sizeof(h->stems.post_array));
+  ASAN_POISON_MEMORY_REGION(&h->mask.post_bytes, sizeof(h->mask.post_bytes));
+  ASAN_POISON_MEMORY_REGION(&h->post_regionIndices, sizeof(h->post_regionIndices));
+
+  for (i = 0; i < CUBE_LE_STACKDEPTH; i++) {
+    ASAN_POISON_MEMORY_REGION(&h->cube[i].pre_composeOpArray, sizeof(h->cube[i].pre_composeOpArray));
+    ASAN_POISON_MEMORY_REGION(&h->cube[i].pre_WV, sizeof(h->cube[i].pre_WV));
+
+    ASAN_POISON_MEMORY_REGION(&h->cube[i].post_composeOpArray, sizeof(h->cube[i].post_composeOpArray));
+    ASAN_POISON_MEMORY_REGION(&h->cube[i].post_WV, sizeof(h->cube[i].post_WV));
+  }
+}
