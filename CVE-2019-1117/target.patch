1582a1583
> 
1587,1597d1587
< #if PLAT_MAC
<     argc = ccommand(&argv);
<     (void)__reopen(stdin); /* Change stdin to binary mode */
< #endif                     /* PLAT_MAC */
< 
< #if PLAT_WIN
<     /* The Microsoft standard C-Library opens stderr in buffered mode in
<        contravention of the C standard. The following code establishes the
<        correct unbuffered mode */
<     (void)setvbuf(stderr, NULL, _IONBF, 0);
< #endif /* PLAT_WIN */
1618,1631c1608,1622
<     if (argc > 1 && getOptionIndex(argv[argc - 2]) == opt_s) {
<         /* Option list ends with script option */
<         int i;
< 
<         /* Copy args preceeding -s */
<         for (i = 0; i < argc - 2; i++)
<             *dnaNEXT(h->script.args) = argv[i];
< 
<         /* Add args from script file */
<         addArgs(h, argv[argc - 1]);
< 
<         parseArgs(h, (int)h->script.args.cnt, h->script.args.array);
<     } else
<         parseArgs(h, argc, argv);
---
>     h->t1r.flags = 0; /* I initialize these here,as I need to set the std Encoding flags before calling setMode. */
>     h->cfr.flags = 0;
>     h->cfw.flags = 0;
>     h->dcf.flags = DCF_AllTables | DCF_BreakFlowed;
>     h->dcf.level = 5;
>     h->svr.flags = 0;
>     h->ufr.flags = 0;
>     h->ufow.flags = 0;
>     h->t1w.options = 0;
> 
>     // 设置cff模式
>     setMode(h, mode_cff);
> 
>     // argv[1] 文件名
>     doSingleFileSet(h, argv[1]);
